### WebGL
2011年ごろに登場。非常に高速で、結果をcanvas要素内にレンダリングする
シェーダーコード GLSL
GLSLが複雑なのでいくつかのWebGLライブラリが作成されている
例:Three.js, Babylon.js, PlayCanvasなど
問題点
- WebGLリリース後に新世代のネイティブGPU APIが登場。多数の新機能を有している。OpenGLは更新予定ないから新機能なし。WebGPUは新しい機能が追加されていく。
  - Microsoft Direct3D
  - Apple Metal
  - Khronos Group Vulkan
- canvasにレンダリングするのが基本なのでGPGPUはあまり得意でない
- 3Dグラフィックスアプリは同時にレンダリングされるオブジェクトの数と新しいレンダリング機能の使用の両方において要求が厳しくなっている

### WebGPU
最新のGPU APIと互換性があり、GPGPUが得意。CPU側で大幅なコストを掛けずに計算ベースのパーティクルや色効果、シャープ化、被写界深度シミュレーションなどの後処理フィルターなどを最新の機能をサポート。また、カリングやスキンモデルなどの高価な計算をGPUで直接処理できる。

GPUとWebGPU API周りのレイヤー
https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API/basic-webgpu-stack.png

WebGPUアダプターはコードの中で使用可能な物理GPUとドライバーを効果的に表す
webworkerの中でも動かせる

パイプラインとは、プログラムの作業を完了させるためのプログラム可能なステージを含む論理構造です。WebGPUは現在、2種類のパイプラインを扱うことができます：
  - レンダーパイプラインは、通常<canvas>要素にグラフィックを描画しますが、画面の外にグラフィックを描画することもできます。レンダーパイプラインには、主に2つのステージがあります：
    - GPUに入力された位置情報をもとに、"頂点シェーダー"が回転、平行移動、遠近などの効果を与えて、3D空間上に頂点を配置するステージ。頂点は、三角形などのプリミティブ（レンダリンググラフィックスの基本構成要素）に組み立てられ、GPUによってラスタライズされ、それぞれが描画キャンバス上のどのピクセルをカバーすべきかを決定する。
    - フラグメントステージでは、フラグメントシェーダが、頂点シェーダが生成したプリミティブで覆われた各ピクセルの色を計算する。この計算には、表面の詳細や仮想ライトの位置と色を示す画像（テクスチャ）などが頻繁に使用されます。
  - コンピュートパイプラインは、一般的な計算を行うためのものです。計算パイプラインには1つの計算ステージがあり、計算シェーダが一般的なデータを受け取り、指定した数のワークグループで並列処理し、結果を1つまたは複数のバッファで返します。バッファにはどのような種類のデータでも格納することができます。

  頂点シェーダは位置や色などの情報を

シェーダーはWebGPU Shader Language(WGSL)と呼ばれる低レベルRustライクな言語で書かれてる

WebGPUアプリの構築ステップ
1. シェーダーモジュールを作成する：WGSLでシェーダーコードを書き、1つまたは複数のシェーダーモジュールにパッケージ化します。
2. canvasのコンテキストを取得し、設定する：<canvas>要素のwebgpuコンテキストを取得し、GPU論理デバイスからレンダリングするグラフィックスに関する情報を受信するように設定します。このステップは、計算パイプラインのみを使用するアプリなど、グラフィック出力がない場合は必要ありません。
3. データを含むリソースを作成します：パイプラインで処理するデータは、アプリがアクセスできるようにGPUバッファやテクスチャに格納する必要があります。
4. パイプラインを作成する：必要なデータ構造、バインディング、シェーダー、リソースレイアウトなど、必要なパイプラインを詳細に記述したパイプライン記述子を定義し、それを元にパイプラインを作成します。基本的なデモには1つのパイプラインしか含まれていませんが、非自明なアプリでは通常、異なる目的のために複数のパイプラインが含まれます。
5. 計算/レンダリングパスを実行します：これにはいくつかのサブステップが含まれます：
  - GPUに渡して実行させるコマンドのセットをエンコードできるコマンドエンコーダを作成します。
  - 計算・描画コマンドを発行するパスエンコーダーオブジェクトを作成します。
  - どのパイプラインを使うか、どのバッファから必要なデータを取得するか、何回描画処理を実行するか（レンダーパイプラインの場合）などを指定するコマンドを実行します。
  - コマンドリストを最終化し、コマンドバッファにカプセル化する。
  - 論理デバイスのコマンドキューを経由して、コマンドバッファをGPUに送信します。

データをGPUBufferに取り込む必要があるのです。このタイプのバッファは、GPUのコアと非常に密接に統合されたメモリに格納され、望ましい高性能処理を可能にする裏側で、このメモリにアクセスすることはできません。副作用として、このメモリは、ブラウザのようなホストシステム上で動作するプロセスからはアクセスできません。

### 計算
基本的な計算デモでは、GPUに値を計算させ、出力バッファに格納し、ステージングバッファにデータをコピーし、ステージングバッファをマッピングして、JavaScriptにデータを読み出し、コンソールにログを記録します。

このアプリは、基本的なレンダリングデモと同様の構造になっています。前と同じように GPUDevice の参照を作成し、GPUDevice.createShaderModule()呼び出しでシェーダーコードを GPUShaderModule にカプセル化します。ここでの違いは、シェーダーコードは1つのシェーダーステージ、@computeステージしか持っていないことです：

### GPUの種類
- CPUと同じボード上に存在し、メモリを共有する統合GPU
- CPUとは別の独自ボード上にあるディスクリートGPU
- CPUに実装されたソフトウェアGPU



### シェーダー
シェーダーとはGPU上で実行される任意にプログラムを指す

データ(座標や色などの頂点の情報)の入ったバッファをGPUにアップロードし、そのデータをどう解釈すれば三角形になるのかをGPUに伝える。頂点は頂点ステージでGPUによって処理される。頂点ステージで実行されるのが頂点シェーダであり、移動・回転・透視変換などを適用する。

GPUは三角形のそれぞれが画面のどのピクセルを覆うかを計算する。三角形でおおわれているピクセルはその後のフラグメントシェーダで処理される。フラグメントシェーダからはピクセル座標や色を決定するために必要な補助データにアクセスできる。

データを頂点シェーダとフラグメントシェーダに通し、出力をスクリーンに直接書き込む一連のシステムはパイプラインと呼ばれる。パイプラインはプログラマが定義する。

ラスタライズ：何らかの抽象度の高い形式で記述された画像データを、コンピュータが最終的に出力することのできる画素の集まり（ビットマップ形式/ラスター形式）に変換すること。一般的にはベクター画像をビットマップ画像に変換することを指すことが多い。

### パイプライン
レンダーパイプライン
画面やメモリ(フレームバッファ)に描画を行う。

コンピュートパイプライン
任意の種類のデータをもったバッファを返せる。

新しくレイトレーシングパイプラインが追加される可能性が高い？

パイプラインは一つ以上のプログラム可能なステージから構成され、各ステージはシェーダとエントリーポイント(wgslで定義する関数名?)で定義される。
@computeがエントリーポイントの印。

コンピュートパイプラインはcomputeという単一のステージを持つ

レンダーパイプラインはvertexとfragmentという2つのステージを持つ

### 並列性
GPUはレイテンシを犠牲にしてスループットを最適化している。

GPUは多量のコアを有しているがそれぞれのコアは独立していない。コアは階層的にグループ化されている。
グループの最も下の階層は実行ユニットと呼ばれ、複数のSIMTコアから構成される。なので、同じ命令を実行しつつも異なるデータを処理できる。

GPUのコアは高い周波数を持つのに対して、メモリからデータを読むのには時間がかかる。サイクルを無題にしないようにEUの仕事が待機状態になったら他の仕事に実行を切り替え、新しい仕事が何かを待機し始めたときに限って元の仕事に実行を戻す。

EUは複数まとめられており、サブスライスと呼ばれるグループを構成している。サブスライスに含まれる全てのEUは小さな共有ローカルメモリへのアクセスを持つ。

最後のレイヤーとして、複数のサブスライスをまとめたスライスがある。スライスはGPUを構成する。

### workgroup
レンダーパイプラインでは頂点シェーダが頂点ごとに一度ずつ起動され、フラグメントシェーダはピクセルごとに一度ずつ起動される。

コンピュートパイプラインではコンピュートシェーダがワークアイテム(プログラマがスケジュールをする)ごとに一度ずつ起動される

ワークロード:ワークアイテムの全ての集合
ワークロードはワークグループに分割され、ワークグループに含まれるワークアイテムは同時に実行するようスケジュールされる。ワークロードは三次元格子としてモデル化され、立方体の1つ1つがワークアイテム、その集まりである直方体がワークグループ。

ただ、チップ上の実際のEUが三次元格子状に並んでいるわけではない。ワークグループを三次元でモデル化しているのは局所性を高めるため。

基本的にはワークグループは64で良いらしい

### コマンド
シェーダが書け、パイプラインのセットアップがすんだら、パイプラインを実行するようにGPUに伝えればよい。

GPUは専用のメモリチップを持つ可能性があるので、その制御はコマンドバッファとコマンドキューを通して行われる。

コマンドキュー:GPUが実行するコマンドをエンコードしたデータを保存するためのメモリ領域。

エンコード処理はGPUごとに大きく異なり、ドライバが担当をする。CommandEncoderを使ってこの機能を利用する

CommandEncoderにはGPUバッファ間でデータをコピーしたりテクスチャを操作したりするためのメソッドがいくつかある。また。パイプラインのセットアップや起動を行う命令のエンコード処理を担当するpassEncoderの作成も行える。

コンピュートパイプラインを実行したいときにはコンピュートパスを作成し、事前に宣言したパイプラインを使うように設定し、最後にdispatch(w_x,w_y,w_z)を呼び出して作成するワークグループの個数を次元ごとにGPUに伝えなければならない。

コマンドバッファ?

### データのやり取り
シミュレーションのパラメータと初期条件をGPUに送信し、GPU上でシミュレーションを実行し、その結果をGPUから読み込む必要がある。

### バインドグループレイアウト
データをGPUとやり取りするにはパイプラインの定義をバインドグループレイアウトで拡張する必要がある。

バインドグループ:パイプラインを実行しているときにアクセス可能となるGPU要素(メモリバッファ、テクスチャメモリ、サンプラーなど)のこと。

バインドグループレイアウト:GPU要素の型、用途、使い方を事前に定義したもの。これがあるとGPUはパイプラインを効率よく実行する方法を実行前に決定できる。

bindingに指定する数値は自由に指定でき、バインドグループレイアウトのこのスロットのバッファをwgslコード中の変数と関連付けるときに使われる。

bindGroupLayoutでは"storage"というバッファの用途が定義されている。これ以外には"read-only-storage"がある。他にも"uniform"があるがコンピュートパイプラインにおいては等価らしい。

バインドグループレイアウトができたから、次には実際のGPU要素のインスタンスを持つバインドグループを作成する。

### ステージングバッファ
スループットの向上のためにはGPUはコアに対して高速にデータを与える必要がある。そのためにはコアとメモリを見つけ都合にさせるほかない。そうした場合、ホストマシンから読み書きができるようにすることは難しくなる。

そのために、GPUにはコアと密結合でない速度が劣るホストマシンからアクセス可能なメモリバンクが存在する。この中間的なメモリ領域に確保されるのがステージングバッファであり、ホストシステムからマップをして読み書きを行える。

GPUの結果書き込み用のバッファであるoutputの作成と、ステージングバッファの作成。(usageが異なる)

コンピュートパイプラインを実行するパスを定義し、コンピュートシェーダの出力バッファからステージングバッファへデータのコピーを行う。その後にコマンドバッファをコマンドキューに送っている。

そしてGPUはコマンドキューに送られたコマンドを実行する。コマンドがいつ終わるかわからないが、ステージングバッファをマップする要求がすぐに送られる。

getMappedRangeを使うことでArrayBufferとしてJavaScriptから見えるようになる。このArrayBufferはマップされた実際のメモリを指すので、unmap()するとdetachedになってしまうので、sliceを用いてJavaScriptで保持されるようなコピーを作成している。


vertex shaderとfragment shaderの間の接続はindexによって行われ、変数はlocationによって接続されている。