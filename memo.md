### WebGL
2011年ごろに登場。非常に高速で、結果をcanvas要素内にレンダリングする
シェーダーコード GLSL
GLSLが複雑なのでいくつかのWebGLライブラリが作成されている
例:Three.js, Babylon.js, PlayCanvasなど
問題点
- WebGLリリース後に新世代のネイティブGPU APIが登場。多数の新機能を有している。OpenGLは更新予定ないから新機能なし。WebGPUは新しい機能が追加されていく。
  - Microsoft Direct3D
  - Apple Metal
  - Khronos Group Vulkan
- canvasにレンダリングするのが基本なのでGPGPUはあまり得意でない
- 3Dグラフィックスアプリは同時にレンダリングされるオブジェクトの数と新しいレンダリング機能の使用の両方において要求が厳しくなっている

### WebGPU
最新のGPU APIと互換性があり、GPGPUが得意。CPU側で大幅なコストを掛けずに計算ベースのパーティクルや色効果、シャープ化、被写界深度シミュレーションなどの後処理フィルターなどを最新の機能をサポート。また、カリングやスキンモデルなどの高価な計算をGPUで直接処理できる。

GPUとWebGPU API周りのレイヤー
https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API/basic-webgpu-stack.png

WebGPUアダプターはコードの中で使用可能な物理GPUとドライバーを効果的に表す
webworkerの中でも動かせる

パイプラインとは、プログラムの作業を完了させるためのプログラム可能なステージを含む論理構造です。WebGPUは現在、2種類のパイプラインを扱うことができます：
  - レンダーパイプラインは、通常<canvas>要素にグラフィックを描画しますが、画面の外にグラフィックを描画することもできます。レンダーパイプラインには、主に2つのステージがあります：
    - GPUに入力された位置情報をもとに、"頂点シェーダー"が回転、平行移動、遠近などの効果を与えて、3D空間上に頂点を配置するステージ。頂点は、三角形などのプリミティブ（レンダリンググラフィックスの基本構成要素）に組み立てられ、GPUによってラスタライズされ、それぞれが描画キャンバス上のどのピクセルをカバーすべきかを決定する。
    - フラグメントステージでは、フラグメントシェーダが、頂点シェーダが生成したプリミティブで覆われた各ピクセルの色を計算する。この計算には、表面の詳細や仮想ライトの位置と色を示す画像（テクスチャ）などが頻繁に使用されます。
  - コンピュートパイプラインは、一般的な計算を行うためのものです。計算パイプラインには1つの計算ステージがあり、計算シェーダが一般的なデータを受け取り、指定した数のワークグループで並列処理し、結果を1つまたは複数のバッファで返します。バッファにはどのような種類のデータでも格納することができます。

シェーダーはWebGPU Shader Language(WGSL)と呼ばれる低レベルRustライクな言語で書かれてる

WebGPUアプリの構築ステップ
1. シェーダーモジュールを作成する：WGSLでシェーダーコードを書き、1つまたは複数のシェーダーモジュールにパッケージ化します。
2. canvasのコンテキストを取得し、設定する：<canvas>要素のwebgpuコンテキストを取得し、GPU論理デバイスからレンダリングするグラフィックスに関する情報を受信するように設定します。このステップは、計算パイプラインのみを使用するアプリなど、グラフィック出力がない場合は必要ありません。
3. データを含むリソースを作成します：パイプラインで処理するデータは、アプリがアクセスできるようにGPUバッファやテクスチャに格納する必要があります。
4. パイプラインを作成する：必要なデータ構造、バインディング、シェーダー、リソースレイアウトなど、必要なパイプラインを詳細に記述したパイプライン記述子を定義し、それを元にパイプラインを作成します。基本的なデモには1つのパイプラインしか含まれていませんが、非自明なアプリでは通常、異なる目的のために複数のパイプラインが含まれます。
5. 計算/レンダリングパスを実行します：これにはいくつかのサブステップが含まれます：
  - GPUに渡して実行させるコマンドのセットをエンコードできるコマンドエンコーダを作成します。
  - 計算・描画コマンドを発行するパスエンコーダーオブジェクトを作成します。
  - どのパイプラインを使うか、どのバッファから必要なデータを取得するか、何回描画処理を実行するか（レンダーパイプラインの場合）などを指定するコマンドを実行します。
  - コマンドリストを最終化し、コマンドバッファにカプセル化する。
  - 論理デバイスのコマンドキューを経由して、コマンドバッファをGPUに送信します。

データをGPUBufferに取り込む必要があるのです。このタイプのバッファは、GPUのコアと非常に密接に統合されたメモリに格納され、望ましい高性能処理を可能にする裏側で、このメモリにアクセスすることはできません。副作用として、このメモリは、ブラウザのようなホストシステム上で動作するプロセスからはアクセスできません。

### 計算
基本的な計算デモでは、GPUに値を計算させ、出力バッファに格納し、ステージングバッファにデータをコピーし、ステージングバッファをマッピングして、JavaScriptにデータを読み出し、コンソールにログを記録します。

このアプリは、基本的なレンダリングデモと同様の構造になっています。前と同じように GPUDevice の参照を作成し、GPUDevice.createShaderModule()呼び出しでシェーダーコードを GPUShaderModule にカプセル化します。ここでの違いは、シェーダーコードは1つのシェーダーステージ、@computeステージしか持っていないことです：

### GPUの種類
- CPUと同じボード上に存在し、メモリを共有する統合GPU
- CPUとは別の独自ボード上にあるディスクリートGPU
- CPUに実装されたソフトウェアGPU
